import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import { stripMarkdown } from './forgeHelpers';

interface ExportMetadata {
  title: string;
  contentType?: string;
  collection?: string;
  dipWeek?: number | null;
  createdAt: string;
  wordCount?: number;
}

export const generateFilename = (contentType: string, title: string, date: string, extension: string): string => {
  const cleanTitle = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);
  
  const cleanDate = new Date(date).toISOString().split('T')[0];
  return `scriptora-${contentType}-${cleanTitle}-${cleanDate}.${extension}`;
};

export const exportAsText = (content: string, metadata: ExportMetadata): void => {
  const cleanContent = stripMarkdown(content);
  const textContent = `${metadata.title}\n${'='.repeat(metadata.title.length)}\n\n${cleanContent}`;
  
  const blob = new Blob([textContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = generateFilename(metadata.contentType || 'content', metadata.title, metadata.createdAt, 'txt');
  link.click();
  URL.revokeObjectURL(url);
};

export const exportAsPDF = (content: string, metadata: ExportMetadata): void => {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4',
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - (2 * margin);
  let yPosition = margin;

  // Title
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(20);
  const titleLines = doc.splitTextToSize(metadata.title, contentWidth);
  doc.text(titleLines, margin, yPosition);
  yPosition += (titleLines.length * 8) + 5;

  // Metadata section
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  
  const metadataItems: string[] = [];
  if (metadata.contentType) metadataItems.push(`Type: ${metadata.contentType}`);
  if (metadata.collection) metadataItems.push(`Collection: ${metadata.collection}`);
  if (metadata.dipWeek) metadataItems.push(`DIP Week: ${metadata.dipWeek}`);
  if (metadata.createdAt) metadataItems.push(`Created: ${new Date(metadata.createdAt).toLocaleDateString()}`);
  if (metadata.wordCount) metadataItems.push(`Words: ${metadata.wordCount}`);
  
  doc.text(metadataItems.join(' • '), margin, yPosition);
  yPosition += 10;

  // Separator line
  doc.setDrawColor(200, 200, 200);
  doc.line(margin, yPosition, pageWidth - margin, yPosition);
  yPosition += 8;

  // Content
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');
  
  const cleanContent = stripMarkdown(content);
  const contentLines = doc.splitTextToSize(cleanContent, contentWidth);
  
  contentLines.forEach((line: string) => {
    if (yPosition > pageHeight - margin) {
      doc.addPage();
      yPosition = margin;
    }
    doc.text(line, margin, yPosition);
    yPosition += 6;
  });

  // Footer with branding
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.setFont('helvetica', 'italic');
    doc.text(
      'Generated by Scriptora',
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
    doc.text(
      `Page ${i} of ${totalPages}`,
      pageWidth - margin,
      pageHeight - 10,
      { align: 'right' }
    );
  }

  doc.save(generateFilename(metadata.contentType || 'content', metadata.title, metadata.createdAt, 'pdf'));
};

export const exportAsDocx = async (content: string, metadata: ExportMetadata): Promise<void> => {
  const cleanContent = stripMarkdown(content);
  
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: metadata.title,
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 },
        }),
        
        // Metadata
        new Paragraph({
          children: [
            new TextRun({
              text: [
                metadata.contentType && `Type: ${metadata.contentType}`,
                metadata.collection && `Collection: ${metadata.collection}`,
                metadata.dipWeek && `DIP Week: ${metadata.dipWeek}`,
                metadata.createdAt && `Created: ${new Date(metadata.createdAt).toLocaleDateString()}`,
                metadata.wordCount && `Words: ${metadata.wordCount}`,
              ].filter(Boolean).join(' • '),
              size: 18,
              color: '666666',
            }),
          ],
          spacing: { after: 300 },
        }),
        
        // Content paragraphs
        ...cleanContent.split('\n\n').map(para => 
          new Paragraph({
            text: para,
            spacing: { after: 200 },
          })
        ),
        
        // Footer
        new Paragraph({
          text: 'Generated by Scriptora',
          alignment: AlignmentType.CENTER,
          spacing: { before: 400 },
          children: [
            new TextRun({
              text: 'Generated by Scriptora',
              size: 16,
              color: '999999',
              italics: true,
            }),
          ],
        }),
      ],
    }],
  });

  const blob = await Packer.toBlob(doc);
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = generateFilename(metadata.contentType || 'content', metadata.title, metadata.createdAt, 'docx');
  link.click();
  URL.revokeObjectURL(url);
};
